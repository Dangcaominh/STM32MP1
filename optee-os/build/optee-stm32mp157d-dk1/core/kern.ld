OUTPUT_FORMAT(elf32-littlearm)
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
 . = 0x2ffc0000;
 ASSERT(!(0x2ffc0000 & ((1 << (12)) - 1)),
        "text start should be page aligned")
 __text_start = .;
 __flatmap_unpg_rx_start = ((__text_start) - ((__text_start) % ((1 << (12)))));
 .text : {
  KEEP(*(.text._start))
  __identity_map_init_start = .;
  __text_data_start = .;
  *(.identity_map.data)
  __text_data_end = .;
  *(.identity_map .identity_map.*
    .text.get_core_pos_mpidr)
  __identity_map_init_end = .;
  KEEP(*(.text.init .text.plat_cpu_reset_early .text.reset .text.reset_primary .text.unhandled_cpu .text.__assert_flat_mapped_range))
  *(.text)
 *(.text.cpu_idle)
 *(.text.arm_cntpct_get_sys_time)
 *(.text.plat_prng_add_jitter_entropy)
 *(.text.__cpu_spin_lock)
 *(.text.__cpu_spin_trylock)
 *(.text.__cpu_spin_unlock)
 *(.text.tlbi_all)
 *(.text.tlbi_va_allasid)
 *(.text.dcache_cleaninv_range)
 *(.text.dcache_inv_range)
 *(.text.dcache_clean_range_pou)
 *(.text.do_dcsw_op)
 *(.text.dcache_op_louis)
 *(.text.dcache_op_all)
 *(.text.dcache_op_level1)
 *(.text.icache_inv_all)
 *(.text.icache_inv_range)
 *(.text.thread_set_abt_sp)
 *(.text.thread_set_und_sp)
 *(.text.thread_set_irq_sp)
 *(.text.thread_set_fiq_sp)
 *(.text.thread_resume)
 *(.text.thread_save_state)
 *(.text.thread_init_vbar)
 *(.text.thread_unwind_user_mode)
 *(.text.thread_excp_vect)
 *(.text.thread_lazy_save_ns_vfp)
 *(.text.thread_lazy_restore_ns_vfp)
 *(.text.__thread_alloc_and_run.constprop.0)
 *(.text.thread_get_exceptions)
 *(.text.thread_set_exceptions)
 *(.text.thread_mask_exceptions)
 *(.text.thread_unmask_exceptions)
 *(.text.thread_alloc_and_run)
 *(.text.thread_pm_alloc_and_run)
 *(.text.thread_resume_from_rpc)
 *(.text.thread_is_in_normal_mode)
 *(.text.thread_state_free)
 *(.text.thread_init_per_cpu)
 *(.text.thread_kernel_save_vfp)
 *(.text.thread_kernel_restore_vfp)
 *(.text.thread_user_enable_vfp)
 *(.text.thread_user_save_vfp)
 *(.text.thread_state_suspend)
 *(.text.thread_scall_handler)
 *(.text.mobj_get_va)
 *(.text.mobj_matches)
 *(.text.mobj_get_cookie)
 *(.text.rpc_shm_mobj_alloc)
 *(.text.thread_rpc_free_arg)
 *(.text.thread_rpc_alloc_arg.constprop.0)
 *(.text.get_rpc_arg.constprop.0)
 *(.text.thread_handle_fast_smc)
 *(.text.thread_handle_std_smc)
 *(.text.thread_handle_pm)
 *(.text.thread_disable_prealloc_rpc_cache)
 *(.text.thread_enable_prealloc_rpc_cache)
 *(.text.thread_rpc_cmd)
 *(.text.thread_std_smc_entry)
 *(.text.thread_pm_entry)
 *(.text.thread_rpc)
 *(.text.thread_foreign_intr_exit)
 *(.text.save_abort_info_in_tsd)
 *(.text.__print_abort_info)
 *(.text.handle_user_mode_panic.isra.0)
 *(.text.abort_print)
 *(.text.abort_print_error)
 *(.text.abort_is_user_exception)
 *(.text.abort_is_write_fault)
 *(.text.plat_abort_handler)
 *(.text.abort_handler)
 *(.text.vfp_is_enabled)
 *(.text.vfp_enable)
 *(.text.vfp_disable)
 *(.text.vfp_lazy_save_state_init)
 *(.text.vfp_lazy_save_state_final)
 *(.text.vfp_lazy_restore_state)
 *(.text.vfp_save_extension_regs)
 *(.text.vfp_restore_extension_regs)
 *(.text.vfp_write_fpexc)
 *(.text.vfp_read_fpexc)
 *(.text.vfp_write_fpscr)
 *(.text.vfp_read_fpscr)
 *(.text.get_core_pos_mpidr)
 *(.text.temp_set_mode)
 *(.text.read_mode_sp)
 *(.text.read_mode_lr)
 *(.text.plat_primary_init_early)
 *(.text.plat_get_random_stack_canaries)
 *(.text.init_sec_mon)
 *(.text.boot_init_secondary)
 *(.text.boot_set_core_ns_entry)
 *(.text.boot_core_release)
 *(.text.boot_core_hpen)
 *(.text.unhandled_cpu)
 *(.text.dummy.boot_init_primary_late)
 *(.text.dummy.__thread_std_smc_entry)
 *(.text.dummy.__thread_pm_entry)
 *(.text.dummy.core_init_mmu_map)
 *(.text.dummy.boot_init_primary_early)
 *(.text.tlbi_va_range)
 *(.text.arch_va2pa_helper)
 *(.text.cpu_mmu_enabled)
 *(.text.get_pgt_count)
 *(.text.find_pager_table_may_fail)
 *(.text.region_va2tblidx)
 *(.text.pmem_assign_fobj_page)
 *(.text.pmem_find)
 *(.text.tblidx_get_entry)
 *(.text.tblidx_set_entry)
 *(.text.to_user_mode_ctx)
 *(.text.tblidx_tlbi_entry)
 *(.text.find_region)
 *(.text.find_uta_region)
 *(.text.fobj_get)
 *(.text.pager_unlock)
 *(.text.make_dirty_page.isra.0)
 *(.text.get_pmem_pa.isra.0)
 *(.text.pager_deploy_page)
 *(.text.tee_pager_unhide_page)
 *(.text.make_iv_available)
 *(.text.pmem_get_region_tblidx.isra.0)
 *(.text.pmem_unmap)
 *(.text.pager_lock_check_stack)
 *(.text.region_insert)
 *(.text.unlink_region)
 *(.text.merge_region_with_next)
 *(.text.tee_pager_invalidate_fobj)
 *(.text.split_region)
 *(.text.rem_region)
 *(.text.tee_pager_pgt_save_and_release_entries)
 *(.text.tee_pager_release_phys)
 *(.text.tee_pager_set_um_region_attr)
 *(.text.tee_pager_get_table_info)
 *(.text.tee_pager_phys_to_virt)
 *(.text.tee_pager_handle_fault)
 *(.text.get_desc_type)
 *(.text.desc_to_mattr)
 *(.text.mattr_to_desc)
 *(.text.core_mmu_set_entry_primitive)
 *(.text.core_mmu_get_entry_primitive)
 *(.text.core_mmu_get_user_map)
 *(.text.core_mmu_set_user_map)
 *(.text.core_mmu_user_mapping_is_active)
 *(.text.core_mmu_get_fault_type)
 *(.text.cpu_spin_lock_xsave_no_dldetect)
 *(.text.cpu_spin_unlock_xrestore)
 *(.text.mobj_put)
 *(.text.mobj_reg_shm_alloc)
 *(.text.mobj_mapped_shm_alloc)
 *(.text.tee_entry_get_api_call_count)
 *(.text.tee_entry_get_api_uuid)
 *(.text.tee_entry_get_api_revision)
 *(.text.tee_entry_get_os_uuid)
 *(.text.tee_entry_get_os_revision)
 *(.text.__tee_entry_fast)
 *(.text.tee_entry_fast)
 *(.text.stm32_dbgmcu_base)
 *(.text.stm32mp1_dbgmcu_get_chip_dev_id)
 *(.text.get_part_number.constprop.0)
 *(.text.boot_secondary_init_intc)
 *(.text.stm32_rcc_base)
 *(.text.get_gicd_base)
 *(.text.may_spin_lock)
 *(.text.may_spin_unlock)
 *(.text.stm32mp_bkpreg)
 *(.text.stm32mp_supports_second_core)
 *(.text.do_reset)
 *(.text.plat_cpu_reset_early)
 *(.text.tzc_it_handler)
 *(.text.dummy.__psci_system_suspend)
 *(.text.dummy.__psci_system_off)
 *(.text.dummy.console_init)
 *(.text.get_ddrctrl_base)
 *(.text.do_sw_handshake)
 *(.text.ddr_set_sr_mode)
 *(.text.timeout_init_us.constprop.0)
 *(.text.do_sw_ack)
 *(.text.ddr_standby_sr_exit)
 *(.text.ddr_restore_sr_mode)
 *(.text.atomic_stm32mp1_stpmic1_notif)
 *(.text.stm32_stpmic1_is_present)
 *(.text.stm32mp_get_pmic)
 *(.text.stm32mp_put_pmic)
 *(.text.pmic_it_handler)
 *(.text.stm32_pwr_base)
 *(.text.stm32mp1_pwr_itr_enable_nolock)
 *(.text.stm32mp1_pwr_op_raise_pi)
 *(.text.stm32mp1_pwr_op_raise_sgi)
 *(.text.stm32mp1_pwr_op_set_affinity)
 *(.text.stm32mp1_pwr_op_set_wake)
 *(.text.pwr_it_handler)
 *(.text.stm32mp1_pwr_op_add)
 *(.text.stm32mp1_pwr_itr_disable_nolock)
 *(.text.stm32mp1_pwr_op_unmask)
 *(.text.stm32mp1_pwr_op_enable)
 *(.text.stm32mp1_pwr_op_disable)
 *(.text.stm32mp1_pwr_op_mask)
 *(.text.sm_platform_handler)
 *(.text.pm_domain_scv_handler)
 *(.text.pwr_scv_handler)
 *(.text.cpu_wfi)
 *(.text.rcc_wakeup_it_handler)
 *(.text.stm32_exit_cstop)
 *(.text.stm32_pm_cpu_power_down_wfi)
 *(.text.stm32mp_sysram_resume)
 *(.text.stm32mp_cpu_reset_state)
 *(.text.stm32mp1_set_pm_domain_state)
 *(.text.psci_affinity_info)
 *(.text.stm32mp_register_online_cpu)
 *(.text.psci_cpu_on)
 *(.text.psci_cpu_off)
 *(.text.psci_system_suspend)
 *(.text.psci_system_off)
 *(.text.psci_system_reset)
 *(.text.psci_features)
 *(.text.psci_version)
 *(.text.sm_save_unbanked_regs)
 *(.text.sm_restore_unbanked_regs)
 *(.text.sm_smc_entry)
 *(.text.sm_fiq_entry)
 *(.text.sm_vect_table)
 *(.text.sm_vect_table_a15)
 *(.text.sm_vect_table_bpiall)
 *(.text.sm_init)
 *(.text.sm_get_nsec_ctx)
 *(.text.sm_from_nsec)
 *(.text.sm_pm_cpu_suspend_save)
 *(.text.sm_pm_cpu_suspend)
 *(.text.sm_pm_cpu_do_suspend)
 *(.text.sm_pm_cpu_resume)
 *(.text.sm_pm_cpu_do_resume)
 *(.text.smc_std_handler)
 *(.text.psci_cpu_suspend)
 *(.text.psci_migrate)
 *(.text.psci_migrate_info_type)
 *(.text.psci_migrate_info_up_cpu)
 *(.text.psci_mem_protect)
 *(.text.psci_mem_chk_range)
 *(.text.psci_system_reset2)
 *(.text.psci_node_hw_state)
 *(.text.tee_psci_handler)
 *(.text.psci_disable_smp)
 *(.text.psci_armv7_cpu_off)
 *(.text.ghash_update_lengths)
 *(.text.__gcm_update_aad)
 *(.text.internal_aes_gcm_inc_ctr)
 *(.text.__gcm_init)
 *(.text.__gcm_update_payload)
 *(.text.operation_final)
 *(.text.internal_aes_gcm_enc)
 *(.text.internal_aes_gcm_dec)
 *(.text.ghash_update_block)
 *(.text.decrypt_block)
 *(.text.encrypt_block)
 *(.text.internal_aes_gcm_set_key)
 *(.text.internal_aes_gcm_ghash_update)
 *(.text.internal_aes_gcm_update_payload_blocks)
 *(.text.internal_aes_gcm_ghash_gen_tbl)
 *(.text.internal_aes_gcm_ghash_mult_tbl)
 *(.text.crypto_rng_hw_is_registered)
 *(.text.crypto_rng_add_event)
 *(.text.crypto_rng_read)
 *(.text.tzc_fail_dump)
 *(.text.gic_op_set_affinity.part.0)
 *(.text.gic_op_raise_pi)
 *(.text.gic_op_disable)
 *(.text.gic_op_enable)
 *(.text.gic_it_set_cpu_mask.isra.0)
 *(.text.gic_op_set_affinity)
 *(.text.gic_op_add)
 *(.text.gic_op_raise_sgi)
 *(.text.gic_cpu_init)
 *(.text.gic_set_pmr)
 *(.text.gic_set_ipriority)
 *(.text.interrupt_main_handler)
 *(.text.stm32_bsec_otp_setting)
 *(.text.bsec_base)
 *(.text.bsec_status)
 *(.text.state_is_invalid_mode)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout.part.0)
 *(.text.stm32_bsec_read_otp)
 *(.text.stm32_bsec_read_debug_conf)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout)
 *(.text.io_clrsetbits32)
 *(.text.stm32_pinctrl_conf_free)
 *(.text.stm32_gpio_get_bank)
 *(.text.pin_is_secure.part.0)
 *(.text.pin_is_secure)
 *(.text.set_gpio_cfg)
 *(.text.stm32_pinctrl_conf_apply)
 *(.text.get_base)
 *(.text.stm32_iwdg_it_ack)
 *(.text.stm32_iwdg_it_handler)
 *(.text.iwdg_wdt_get_timeleft)
 *(.text.stm32_iwdg_handle_big_timeout)
 *(.text.iwdg_wdt_init)
 *(.text.iwdg_wdt_stop.part.0)
 *(.text.iwdg_refresh)
 *(.text.iwdg_wdt_refresh)
 *(.text.iwdg_wait_sync)
 *(.text.iwdg_wdt_stop)
 *(.text.iwdg_timeout_cnt.isra.0)
 *(.text.configure_timeout)
 *(.text.iwdg_wdt_start)
 *(.text.iwdg_wdt_set_timeout)
 *(.text.timeout_init_us)
 *(.text.i2c_ack_failed)
 *(.text.i2c_transfer_config)
 *(.text.is_thread_context)
 *(.text.lock_i2c_bus_access)
 *(.text.unlock_i2c_bus_access)
 *(.text.i2c_wait_stop)
 *(.text.wait_isr_event)
 *(.text.i2c_wait_txis)
 *(.text.stm32_i2c_read_write_membyte)
 *(.text.stm32_i2c_resume)
 *(.text.stm32_i2c_suspend)
 *(.text.stm32_ltdc_it_handler)
 *(.text.disable_rng_clock)
 *(.text.enable_rng_clock)
 *(.text.conceal_seed_error)
 *(.text.stm32_rng_read)
 *(.text.hw_get_random_bytes)
 *(.text.stm32_rtc_it_handler)
 *(.text.stm32_rtc_fill_date.isra.0)
 *(.text.stm32_rtc_fill_time.isra.0)
 *(.text.stm32_rtc_get_timestamp)
 *(.text.stm32_rtc_is_timestamp_enable)
 *(.text.io_mask32_stm32shregs)
 *(.text.stm32_tamp_it_handler)
 *(.text.stm32_tamp_itamper_action)
 *(.text.stm32_tamp_etamper_action)
 *(.text.loc_chip_clk_is_enabled)
 *(.text.loc_have_rx_data)
 *(.text.loc_putc)
 *(.text.loc_flush)
 *(.text.loc_getchar)
 *(.text.stpmic1_register_read)
 *(.text.stpmic1_register_write)
 *(.text.stpmic2_register_read)
 *(.text.stpmic2_register_write)
 *(.text.stpmic2_register_update)
 *(.text.stpmic2_regulator_set_state)
 *(.text.stpmic2_handle_irq)
 *(.text.atomic_stm32mp2_stpmic2_notif)
 *(.text.stpmic2_irq_callback)
 *(.text.stm32_stpmic2_is_present)
 *(.text.clk_disable_no_lock)
 *(.text.clk_enable_no_lock)
 *(.text.clk_enable)
 *(.text.clk_disable)
 *(.text.clk_get_rate)
 *(.text.clk_stm32_get_priv)
 *(.text.clock_id_to_clk)
 *(.text.clk_stm32_get_rate_oscillateur)
 *(.text.__clk_enable)
 *(.text.__clk_disable)
 *(.text.clk_op_enable)
 *(.text.stm32mp1_read_pll_freq)
 *(.text.get_clock_rate)
 *(.text._stm32_clock_get_rate)
 *(.text.clk_op_compute_rate)
 *(.text.clk_op_is_enabled)
 *(.text.clk_op_disable)
 *(.text.stm32mp_rcc_clock_id_to_clk)
 *(.text.stm32_reset_system)
 *(.text.pinctrl_apply_state)
 *(.text.to_rstline)
 *(.text.stm32_reset_get_ops)
 *(.text.reset_deassert)
 *(.text.reset_assert)
 *(.text.__wdt_sm_handler)
 *(.text.console_putc)
 *(.text.console_flush)
 *(.text.interrupt_get_main_chip)
 *(.text.interrupt_get_main_chip_may_fail)
 *(.text.interrupt_call_handlers)
 *(.text.multi_core_panic_it_handler)
 *(.text.__do_panic)
 *(.text.plat_trace_ext_puts)
 *(.text.trace_ext_puts)
 *(.text.trace_ext_get_thread_id)
 *(.text.trace_ext_get_core_id)
 *(.text.refcount_inc)
 *(.text.refcount_dec)
 *(.text.udelay)
 *(.text.mdelay)
 *(.text.tee_time_get_sys_time)
 *(.text.is_valid_conf_and_notnull_size)
 *(.text.core_is_buffer_inside)
 *(.text.ts_get_current_session_may_fail)
 *(.text.ts_get_current_session)
 *(.text.__mutex_unlock.constprop.0)
 *(.text.__mutex_lock.constprop.0)
 *(.text.mutex_unlock)
 *(.text.mutex_lock)
 *(.text.mutex_pm_aware_lock)
 *(.text.mutex_pm_aware_unlock)
 *(.text.cpu_spin_lock_xsave_no_dldetect.constprop.0)
 *(.text.wq_wait_init_condvar)
 *(.text.wq_wait_final)
 *(.text.wq_wake_next)
 *(.text.notif_rpc)
 *(.text.notif_wait)
 *(.text.notif_send_sync)
 *(.text.thread_check_canaries)
 *(.text.thread_lock_global)
 *(.text.thread_unlock_global)
 *(.text.thread_get_core_local)
 *(.text.thread_clr_boot_thread)
 *(.text.thread_get_tmp_sp)
 *(.text.thread_is_from_abort_mode)
 *(.text.thread_get_id_may_fail)
 *(.text.thread_is_for_pm)
 *(.text.thread_get_id)
 *(.text.thread_init_thread_core_local)
 *(.text.thread_get_tsd)
 *(.text.thread_get_ctx_regs)
 *(.text.thread_restore_foreign_intr)
 *(.text.is_user_ta_ctx)
 *(.text.mobj_shm_alloc)
 *(.text.rwp_paged_iv_get_iv_vaddr)
 *(.text.rop_save_page)
 *(.text.rwp_save_page)
 *(.text.rwp_paged_iv_save_page)
 *(.text.lop_load_page)
 *(.text.rop_load_page)
 *(.text.rwp_load_page)
 *(.text.rwp_paged_iv_load_page)
 *(.text.rwp_unpaged_iv_load_page)
 *(.text.lop_save_page)
 *(.text.rwp_unpaged_iv_save_page)
 *(.text.mobj_get_pa)
 *(.text.vm_pa2va)
 *(.text.pa_is_in_map)
 *(.text.find_map_by_type_and_pa)
 *(.text.find_map_by_pa)
 *(.text._pbuf_is_inside)
 *(.text.phys_to_virt.part.0)
 *(.text.core_mmu_nsec_ddr_is_defined)
 *(.text.core_pbuf_is)
 *(.text.core_mmu_set_entry)
 *(.text.core_mmu_get_entry)
 *(.text.virt_to_phys)
 *(.text.phys_to_virt)
 *(.text.phys_to_virt_io)
 *(.text.io_pa_or_va)
 *(.text.io_pa_or_va_secure)
 *(.text.hash_sha256_check)
 *(.text.crypto_aes_enc_block)
 *(.text.rijndael_ecb_encrypt)
 *(.text.sha256_init)
 *(.text.s_sha256_compress)
 *(.text.sha256_done)
 *(.text.sha256_process)
 *(.text.buf_get_pos)
 *(.text.bget)
 *(.text.bgetz)
 *(.text.brel)
 *(.text.raw_free)
 *(.text.free_helper)
 *(.text.raw_calloc)
 *(.text.raw_realloc)
 *(.text.calloc)
 *(.text.realloc)
 *(.text.free)
 *(.text.__stack_chk_fail)
 *(.text.memchr)
 *(.text.memcpy)
 *(.text.memset)
 *(.text.strcmp)
 *(.text.strlen)
 *(.text.__aeabi_uldivmod)
 *(.text.ul_div_qr)
 *(.text.__ul_divmod)
 *(.text.__vsnprintf)
 *(.text.vsnprintk)
 *(.text.snprintk)
 *(.text.kprintf.constprop.0)
 *(.text.trace_vprintf)
 *(.text.trace_printf)
 *(.text.consttime_memcmp)
  *(.sram.text.glue_7* .gnu.linkonce.t.*)
  . = ALIGN(8);
 }
 __text_end = .;
 __flatmap_unpg_rx_size = . - __flatmap_unpg_rx_start;
 __flatmap_unpg_ro_start = .;
 .rodata : ALIGN(8) {
  __rodata_start = .;
  *(.gnu.linkonce.r.*)
  *(.rodata .rodata.__unpaged .rodata.__unpaged.*)
 *(.rodata.str1.1.core/arch/arm/kernel/tee_time_arm_cntpct.c)
 *(.rodata.arm_cntpct_time_source)
 *(.rodata.__print_abort_info.str1.1)
 *(.rodata.abort_print.str1.1)
 *(.rodata.abort_print_error.str1.1)
 *(.rodata.abort_handler.str1.1)
 *(.rodata.plat_get_random_stack_canaries.str1.1)
 *(.rodata.boot_init_secondary.str1.1)
 *(.rodata.__func__.0)
 *(.rodata.__func__.4)
 *(.rodata.dummy)
 *(.rodata.pager_deploy_page.str1.1)
 *(.rodata.tee_pager_handle_fault.str1.1)
 *(.rodata.__func__.1)
 *(.rodata.CSWTCH.19)
 *(.rodata.__tee_entry_fast.str1.1)
 *(.rodata.get_part_number.constprop.0.str1.1)
 *(.rodata.do_reset.str1.1)
 *(.rodata.__func__.2)
 *(.rodata.tzc_it_handler.str1.1)
 *(.rodata.ddr_set_sr_mode.str1.1)
 *(.rodata.stm32mp1_pwr_itr_ops)
 *(.rodata.allowed_regs)
 *(.rodata.rcc_wakeup_it_handler.str1.1)
 *(.rodata.psci_cpu_off.str1.1)
 *(.rodata.psci_system_reset.str1.1)
 *(.rodata.CSWTCH.16)
 *(.rodata.last4)
 *(.rodata.tzc_fail_dump.str1.1)
 *(.rodata.interrupt_main_handler.str1.1)
 *(.rodata.gic_ops)
 *(.rodata.stm32_pinctrl_conf_apply.str1.1)
 *(.rodata.__func__.6)
 *(.rodata.stm32_pinctrl_ops)
 *(.rodata.stm32_iwdg_it_handler.str1.1)
 *(.rodata.stm32_iwdg_ops)
 *(.rodata.stm32_ltdc_it_handler.str1.1)
 *(.rodata.conceal_seed_error.str1.1)
 *(.rodata.stm32_tamp_it_handler.str1.1)
 *(.rodata.stm32_tamp_itamper_action.str1.1)
 *(.rodata.stm32_tamp_etamper_action.str1.1)
 *(.rodata.__func__.5)
 *(.rodata.str1.1.core/drivers/stm32_tamp.c)
 *(.rodata.itamper_name)
 *(.rodata.stm32_uart_serial_ops)
 *(.rodata.stpmic2_register_read.str1.1)
 *(.rodata.stpmic2_register_write.str1.1)
 *(.rodata.stpmic2_handle_irq.str1.1)
 *(.rodata.__func__.3)
 *(.rodata.str1.1.core/drivers/stpmic2.c)
 *(.rodata.regul_table)
 *(.rodata.refddr_volt_table)
 *(.rodata.ldo4_volt_table)
 *(.rodata.ldo1_volt_table)
 *(.rodata.ldo235678_volt_table)
 *(.rodata.buck_high_volt_table)
 *(.rodata.buck_low_volt_table)
 *(.rodata.pmic_it_handler.str1.1)
 *(.rodata.parent_mp15)
 *(.rodata.dividers_mp15)
 *(.rodata.ck_trace_div_table)
 *(.rodata.apb_div_table)
 *(.rodata.mcu_div_table)
 *(.rodata.axi_div_table)
 *(.rodata.gates_mp15)
 *(.rodata.stm32mp1_axi_div)
 *(.rodata.stm32mp1_mpu_apbx_div)
 *(.rodata.stm32mp1_mcu_div)
 *(.rodata.stm32mp1_clk_pll)
 *(.rodata.pllncfgr2)
 *(.rodata.stm32mp1_clk_sel)
 *(.rodata.rtc_parents)
 *(.rodata.mcuss_parents)
 *(.rodata.axiss_parents)
 *(.rodata.uart234578_parents)
 *(.rodata.uart6_parents)
 *(.rodata.mpu_parents)
 *(.rodata.rng1_parents)
 *(.rodata.usart1_parents)
 *(.rodata.spi6_parents)
 *(.rodata.i2c46_parents)
 *(.rodata.stgen_parents)
 *(.rodata.stm32mp1_clk_on)
 *(.rodata.stm32mp1_clk_gate)
 *(.rodata.parent_id_clock_id)
 *(.rodata.pinctrl_apply_state.str1.1)
 *(.rodata.stm32mp1_reset_data)
 *(.rodata.no_name)
 *(.rodata.interrupt_call_handlers.str1.1)
 *(.rodata.multi_core_panic_it_handler.str1.1)
 *(.rodata.__do_panic.str1.1)
 *(.rodata.trace_ext_prefix)
 *(.rodata.thread_check_canaries.str1.1)
 *(.rodata.Te4)
 *(.rodata.TE0)
 *(.rodata.K)
 *(.rodata.__stack_chk_fail.str1.1)
 *(.rodata.kprintf.constprop.0.str1.1)
 *(.rodata.HEXDIGITS)
 *(.rodata.hexdigits)
 *(.rodata.trace_vprintf.str1.1)
 *(.rodata.lvl_strs.0)
  . = ALIGN(8);
  __rodata_end = .;
 }
 .got : { *(.got.plt) *(.got) }
 .note.gnu.property : { *(.note.gnu.property) }
 .plt : { *(.plt) }
 .ctors : ALIGN(8) {
  __ctor_list = .;
  KEEP(*(.ctors .ctors.* .init_array .init_array.*))
  __ctor_end = .;
 }
 .dtors : ALIGN(8) {
  __dtor_list = .;
  KEEP(*(.dtors .dtors.* .fini_array .fini_array.*))
  __dtor_end = .;
 }
 .ARM.exidx : {
  __exidx_start = .;
  *(.ARM.exidx* .gnu.linkonce.armexidx.*)
  __exidx_end = .;
 }
 .ARM.extab : {
  __extab_start = .;
  *(.ARM.extab*)
  __extab_end = .;
 }
 . = ALIGN((1 << (12)));
 __flatmap_unpg_ro_size = . - __flatmap_unpg_ro_start;
 __flatmap_unpg_rw_start = .;
 .data : ALIGN(8) {
  __data_start_rom = .;
  __data_start = .;
  *(.data .data.* .gnu.linkonce.d.*)
  . = ALIGN(8);
 }
 .bss : {
  __data_end = .;
  __bss_start = .;
  *(.bss .bss.*)
  *(.gnu.linkonce.b.*)
  *(COMMON)
  . = ALIGN(8);
  __bss_end = .;
 }
 .heap1 (NOLOAD) : {
  __heap1_start = .;
  . = ALIGN(16 * 1024);
  __heap1_end = .;
 }
 .nozi (NOLOAD) : {
  __nozi_start = .;
  KEEP(*(.nozi .nozi.*))
  . = ALIGN(16);
  __nozi_end = .;
  __nozi_stack_start = .;
  KEEP(*(.nozi_stack .nozi_stack.*))
  . = ALIGN(8);
  __nozi_stack_end = .;
 }
 .heap2 (NOLOAD) : {
  __heap2_start = .;
  . += 49152 - (__heap1_end - __heap1_start);
  . = ALIGN((1 << (12)));
  __heap2_end = .;
 }
 __flatmap_unpg_rw_size = . - __flatmap_unpg_rw_start;
 __init_start = .;
 __flatmap_init_rx_start = .;
 ASSERT(!(__flatmap_init_rx_start & ((1 << (12)) - 1)),
  "read-write memory is not paged aligned")
 .text_init : {
  __text_init_start = .;
 *(.text.cpu_idle)
 *(.text.__cpu_spin_lock)
 *(.text.__cpu_spin_trylock)
 *(.text.__cpu_spin_unlock)
 *(.text.tlbi_all)
 *(.text.tlbi_va_allasid)
 *(.text.dcache_cleaninv_range)
 *(.text.dcache_inv_range)
 *(.text.dcache_clean_range_pou)
 *(.text.do_dcsw_op)
 *(.text.dcache_op_louis)
 *(.text.dcache_op_all)
 *(.text.dcache_op_level1)
 *(.text.icache_inv_all)
 *(.text.icache_inv_range)
 *(.text.thread_set_abt_sp)
 *(.text.thread_set_und_sp)
 *(.text.thread_set_irq_sp)
 *(.text.thread_set_fiq_sp)
 *(.text.thread_resume)
 *(.text.thread_save_state)
 *(.text.thread_init_vbar)
 *(.text.thread_unwind_user_mode)
 *(.text.thread_excp_vect)
 *(.text.thread_lazy_save_ns_vfp)
 *(.text.thread_lazy_restore_ns_vfp)
 *(.text.__thread_alloc_and_run.constprop.0)
 *(.text.thread_get_exceptions)
 *(.text.thread_set_exceptions)
 *(.text.thread_mask_exceptions)
 *(.text.thread_unmask_exceptions)
 *(.text.thread_alloc_and_run)
 *(.text.thread_pm_alloc_and_run)
 *(.text.thread_resume_from_rpc)
 *(.text.thread_state_free)
 *(.text.thread_init_stack)
 *(.text.thread_init_primary)
 *(.text.thread_init_per_cpu)
 *(.text.thread_kernel_save_vfp)
 *(.text.thread_kernel_restore_vfp)
 *(.text.thread_user_enable_vfp)
 *(.text.thread_user_save_vfp)
 *(.text.thread_state_suspend)
 *(.text.thread_scall_handler)
 *(.text.thread_handle_fast_smc)
 *(.text.thread_handle_std_smc)
 *(.text.thread_handle_pm)
 *(.text.thread_disable_prealloc_rpc_cache)
 *(.text.thread_enable_prealloc_rpc_cache)
 *(.text.thread_std_smc_entry)
 *(.text.thread_pm_entry)
 *(.text.thread_foreign_intr_exit)
 *(.text.save_abort_info_in_tsd)
 *(.text.__print_abort_info)
 *(.text.handle_user_mode_panic.isra.0)
 *(.text.abort_print)
 *(.text.abort_print_error)
 *(.text.abort_is_user_exception)
 *(.text.abort_is_write_fault)
 *(.text.plat_abort_handler)
 *(.text.abort_handler)
 *(.text.vfp_is_enabled)
 *(.text.vfp_enable)
 *(.text.vfp_disable)
 *(.text.vfp_lazy_save_state_init)
 *(.text.vfp_lazy_save_state_final)
 *(.text.vfp_lazy_restore_state)
 *(.text.vfp_save_extension_regs)
 *(.text.vfp_restore_extension_regs)
 *(.text.vfp_write_fpexc)
 *(.text.vfp_read_fpexc)
 *(.text.vfp_write_fpscr)
 *(.text.vfp_read_fpscr)
 *(.text.get_core_pos_mpidr)
 *(.text.temp_set_mode)
 *(.text.read_mode_sp)
 *(.text.read_mode_lr)
 *(.text.plat_primary_init_early)
 *(.text.plat_get_random_stack_canaries)
 *(.text.init_sec_mon)
 *(.text.boot_init_primary_early)
 *(.text.boot_init_secondary)
 *(.text.boot_set_core_ns_entry)
 *(.text.boot_core_release)
 *(.text.boot_core_hpen)
 *(.text._start)
 *(.text.unhandled_cpu)
 *(.text.dummy.boot_init_primary_late)
 *(.text.dummy.__thread_std_smc_entry)
 *(.text.dummy.__thread_pm_entry)
 *(.text.tlbi_va_range)
 *(.text.arch_va2pa_helper)
 *(.text.cpu_mmu_enabled)
 *(.text.get_pgt_count)
 *(.text.find_pager_table_may_fail)
 *(.text.region_va2tblidx)
 *(.text.pmem_assign_fobj_page)
 *(.text.pmem_find)
 *(.text.alloc_region)
 *(.text.tblidx_get_entry)
 *(.text.tblidx_set_entry)
 *(.text.to_user_mode_ctx)
 *(.text.tblidx_tlbi_entry)
 *(.text.find_region)
 *(.text.find_uta_region)
 *(.text.fobj_get)
 *(.text.fobj_put)
 *(.text.pager_unlock)
 *(.text.make_dirty_page.isra.0)
 *(.text.get_pmem_pa.isra.0)
 *(.text.pager_deploy_page)
 *(.text.tee_pager_unhide_page)
 *(.text.make_iv_available)
 *(.text.pmem_get_region_tblidx.isra.0)
 *(.text.pmem_unmap)
 *(.text.pager_lock_check_stack)
 *(.text.region_insert)
 *(.text.tee_pager_release_phys)
 *(.text.tee_pager_get_stats)
 *(.text.tee_pager_get_table_info)
 *(.text.tee_pager_phys_to_virt)
 *(.text.tee_pager_set_alias_area)
 *(.text.tee_pager_early_init)
 *(.text.tee_pager_add_core_region)
 *(.text.tee_pager_handle_fault)
 *(.text.tee_pager_add_pages)
 *(.text.tee_pager_alloc)
 *(.text.get_desc_type)
 *(.text.desc_to_mattr)
 *(.text.mattr_to_desc)
 *(.text.core_mmu_find_table)
 *(.text.core_mmu_set_entry_primitive)
 *(.text.core_mmu_entry_to_finer_grained)
 *(.text.core_mmu_get_entry_primitive)
 *(.text.core_mmu_get_user_va_range)
 *(.text.core_mmu_get_user_map)
 *(.text.core_mmu_set_user_map)
 *(.text.core_mmu_user_mapping_is_active)
 *(.text.core_init_mmu_prtn)
 *(.text.core_init_mmu)
 *(.text.core_init_mmu_regs)
 *(.text.core_mmu_get_fault_type)
 *(.text.tee_entry_get_api_call_count)
 *(.text.tee_entry_get_api_uuid)
 *(.text.tee_entry_get_api_revision)
 *(.text.tee_entry_get_os_uuid)
 *(.text.tee_entry_get_os_revision)
 *(.text.__tee_entry_fast)
 *(.text.tee_entry_fast)
 *(.text.stm32_dbgmcu_base)
 *(.text.console_init)
 *(.text.stm32mp1_dbgmcu_get_chip_dev_id)
 *(.text.get_part_number.constprop.0)
 *(.text.boot_secondary_init_intc)
 *(.text.stm32_rcc_base)
 *(.text.get_gicd_base)
 *(.text.may_spin_lock)
 *(.text.may_spin_unlock)
 *(.text.stm32mp_bkpreg)
 *(.text.stm32mp_supports_second_core)
 *(.text.do_reset)
 *(.text.plat_cpu_reset_early)
 *(.text.dummy.__psci_system_suspend)
 *(.text.dummy.__psci_system_off)
 *(.text.get_ddrctrl_base)
 *(.text.do_sw_handshake)
 *(.text.ddr_set_sr_mode)
 *(.text.timeout_init_us.constprop.0)
 *(.text.do_sw_ack)
 *(.text.ddr_standby_sr_exit)
 *(.text.ddr_restore_sr_mode)
 *(.text.stm32_stpmic1_is_present)
 *(.text.stm32_pwr_base)
 *(.text.sm_platform_handler)
 *(.text.pm_domain_scv_handler)
 *(.text.pwr_scv_handler)
 *(.text.cpu_wfi)
 *(.text.stm32_exit_cstop)
 *(.text.stm32_pm_cpu_power_down_wfi)
 *(.text.stm32mp_sysram_resume)
 *(.text.stm32mp_cpu_reset_state)
 *(.text.stm32mp1_set_pm_domain_state)
 *(.text.psci_affinity_info)
 *(.text.stm32mp_register_online_cpu)
 *(.text.psci_cpu_on)
 *(.text.psci_cpu_off)
 *(.text.psci_system_suspend)
 *(.text.psci_system_off)
 *(.text.psci_system_reset)
 *(.text.psci_features)
 *(.text.psci_version)
 *(.text.sm_save_unbanked_regs)
 *(.text.sm_restore_unbanked_regs)
 *(.text.sm_smc_entry)
 *(.text.sm_fiq_entry)
 *(.text.sm_vect_table)
 *(.text.sm_vect_table_a15)
 *(.text.sm_vect_table_bpiall)
 *(.text.sm_init)
 *(.text.sm_get_nsec_ctx)
 *(.text.sm_from_nsec)
 *(.text.sm_pm_cpu_resume)
 *(.text.smc_std_handler)
 *(.text.psci_cpu_suspend)
 *(.text.psci_migrate)
 *(.text.psci_migrate_info_type)
 *(.text.psci_migrate_info_up_cpu)
 *(.text.psci_mem_protect)
 *(.text.psci_mem_chk_range)
 *(.text.psci_system_reset2)
 *(.text.psci_node_hw_state)
 *(.text.tee_psci_handler)
 *(.text.psci_disable_smp)
 *(.text.psci_armv7_cpu_off)
 *(.text.crypto_rng_hw_is_registered)
 *(.text.crypto_rng_read)
 *(.text.gic_cpu_init)
 *(.text.gic_set_pmr)
 *(.text.gic_set_ipriority)
 *(.text.interrupt_main_handler)
 *(.text.stm32_bsec_otp_setting)
 *(.text.bsec_base)
 *(.text.bsec_status)
 *(.text.state_is_invalid_mode)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout.part.0)
 *(.text.stm32_bsec_read_otp)
 *(.text.stm32_bsec_read_debug_conf)
 *(.text.stm32_bsec_find_otp_in_nvmem_layout)
 *(.text.get_base)
 *(.text.disable_rng_clock)
 *(.text.enable_rng_clock)
 *(.text.conceal_seed_error)
 *(.text.stm32_rng_read)
 *(.text.hw_get_random_bytes)
 *(.text.io_mask32_stm32shregs)
 *(.text.loc_chip_clk_is_enabled)
 *(.text.loc_have_rx_data)
 *(.text.loc_putc)
 *(.text.loc_flush)
 *(.text.loc_getchar)
 *(.text.stm32_uart_init)
 *(.text.stm32_stpmic2_is_present)
 *(.text.clk_disable_no_lock)
 *(.text.clk_enable_no_lock)
 *(.text.clk_enable)
 *(.text.clk_disable)
 *(.text.clock_id_to_clk)
 *(.text.stm32mp_rcc_clock_id_to_clk)
 *(.text.stm32_reset_system)
 *(.text.__wdt_sm_handler)
 *(.text.console_putc)
 *(.text.console_flush)
 *(.text.register_serial_console)
 *(.text.interrupt_get_main_chip)
 *(.text.interrupt_get_main_chip_may_fail)
 *(.text.interrupt_call_handlers)
 *(.text.__do_panic)
 *(.text.plat_trace_ext_puts)
 *(.text.trace_ext_puts)
 *(.text.trace_ext_get_thread_id)
 *(.text.trace_ext_get_core_id)
 *(.text.refcount_inc)
 *(.text.refcount_dec)
 *(.text.udelay)
 *(.text.mdelay)
 *(.text.is_valid_conf_and_notnull_size)
 *(.text.core_is_buffer_inside)
 *(.text.ts_get_current_session_may_fail)
 *(.text.ts_get_current_session)
 *(.text.scattered_array_relax_ptr)
 *(.text.thread_init_canaries)
 *(.text.thread_check_canaries)
 *(.text.thread_lock_global)
 *(.text.thread_unlock_global)
 *(.text.thread_get_core_local)
 *(.text.thread_clr_boot_thread)
 *(.text.thread_get_tmp_sp)
 *(.text.thread_is_from_abort_mode)
 *(.text.thread_get_id_may_fail)
 *(.text.thread_get_id)
 *(.text.thread_init_threads)
 *(.text.thread_init_boot_thread)
 *(.text.thread_init_thread_core_local)
 *(.text.thread_init_core_local_stacks)
 *(.text.thread_get_tsd)
 *(.text.thread_get_ctx_regs)
 *(.text.thread_restore_foreign_intr)
 *(.text.is_user_ta_ctx)
 *(.text.fobj_ro_paged_alloc)
 *(.text.fobj_locked_paged_alloc)
 *(.text.mobj_get_pa)
 *(.text.vm_pa2va)
 *(.text.pa_is_in_map)
 *(.text.find_map_by_type_and_pa)
 *(.text.find_map_by_pa)
 *(.text.cmp_mmap_by_lower_va)
 *(.text._pbuf_is_inside)
 *(.text.phys_to_virt.part.0)
 *(.text.add_va_space.constprop.0)
 *(.text.add_phys_mem.constprop.0)
 *(.text.map_is_tee_ram.isra.0)
 *(.text.core_mmu_nsec_ddr_is_defined)
 *(.text.core_mmu_type_to_attr)
 *(.text.map_is_secure.isra.0)
 *(.text.assign_mem_va_dir)
 *(.text.cmp_init_mem_map)
 *(.text.core_mmu_prefer_tee_ram_at_top)
 *(.text.core_init_mmu_map)
 *(.text.core_pbuf_is)
 *(.text.core_mmu_get_mem_by_type)
 *(.text.core_mmu_get_type_by_pa)
 *(.text.core_mmu_set_entry)
 *(.text.core_mmu_get_entry)
 *(.text.core_mmu_map_region)
 *(.text.virt_to_phys)
 *(.text.phys_to_virt)
 *(.text.phys_to_virt_io)
 *(.text.io_pa_or_va)
 *(.text.io_pa_or_va_secure)
 *(.text.core_mmu_init_ta_ram)
 *(.text.pgt_init)
 *(.text.tee_mm_stats_allocated)
 *(.text.cpu_spin_lock_xsave_no_dldetect)
 *(.text.cpu_spin_unlock_xrestore)
 *(.text.pfree.isra.0)
 *(.text.tee_mm_init)
 *(.text.tee_mm_alloc)
 *(.text.tee_mm_alloc2)
 *(.text.tee_mm_free)
 *(.text.tee_mm_final)
 *(.text.tee_mm_get_bytes)
 *(.text.tee_mm_is_empty)
 *(.text.tee_mm_get_smem)
 *(.text.hash_sha256_check)
 *(.text.sha256_init)
 *(.text.s_sha256_compress)
 *(.text.sha256_done)
 *(.text.sha256_process)
 *(.text.buf_get_pos)
 *(.text.bget)
 *(.text.raw_memalign.part.0)
 *(.text.bgetz)
 *(.text.brel)
 *(.text.bpool)
 *(.text.raw_malloc)
 *(.text.raw_free)
 *(.text.free_helper)
 *(.text.raw_calloc)
 *(.text.raw_realloc)
 *(.text.malloc)
 *(.text.calloc)
 *(.text.free)
 *(.text.raw_malloc_add_pool)
 *(.text.malloc_add_pool)
 *(.text.med3)
 *(.text.swapfunc)
 *(.text.qsort)
 *(.text.__stack_chk_fail)
 *(.text.memchr)
 *(.text.memcpy)
 *(.text.memmove)
 *(.text.memset)
 *(.text.strcmp)
 *(.text.strlen)
 *(.text.__aeabi_uldivmod)
 *(.text.ul_div_qr)
 *(.text.__ul_divmod)
 *(.text.__vsnprintf)
 *(.text.vsnprintk)
 *(.text.snprintk)
 *(.text.kprintf.constprop.0)
 *(.text.trace_vprintf)
 *(.text.trace_printf)
 *(.text.consttime_memcmp)
  KEEP(*(.text.startup.*));
  KEEP(*(.text._GLOBAL__sub_*));
  . = ALIGN(8);
  __text_init_end = .;
 }
 __flatmap_init_rx_size = . - __flatmap_init_rx_start;
 __flatmap_init_ro_start = .;
 .rodata_init : {
  __rodata_init_start = .;
 *(.rodata.__print_abort_info.str1.1)
 *(.rodata.abort_print.str1.1)
 *(.rodata.abort_print_error.str1.1)
 *(.rodata.abort_handler.str1.1)
 *(.rodata.plat_get_random_stack_canaries.str1.1)
 *(.rodata.boot_init_primary_early.str1.1)
 *(.rodata.boot_init_secondary.str1.1)
 *(.rodata.__func__.0)
 *(.rodata.__func__.1)
 *(.rodata.__func__.2)
 *(.rodata.__func__.4)
 *(.rodata.dummy)
 *(.rodata.alloc_region.str1.1)
 *(.rodata.pager_deploy_page.str1.1)
 *(.rodata.tee_pager_early_init.str1.1)
 *(.rodata.tee_pager_add_core_region.str1.1)
 *(.rodata.tee_pager_handle_fault.str1.1)
 *(.rodata.tee_pager_add_pages.str1.1)
 *(.rodata.core_init_mmu_regs.str1.1)
 *(.rodata.CSWTCH.19)
 *(.rodata.__tee_entry_fast.str1.1)
 *(.rodata.console_init.str1.1)
 *(.rodata.get_part_number.constprop.0.str1.1)
 *(.rodata.do_reset.str1.1)
 *(.rodata.__func__.9)
 *(.rodata.str1.1.core/arch/arm/plat-stm32mp1/main.c)
 *(.rodata.ddr_set_sr_mode.str1.1)
 *(.rodata.allowed_regs)
 *(.rodata.psci_cpu_off.str1.1)
 *(.rodata.psci_system_reset.str1.1)
 *(.rodata.CSWTCH.16)
 *(.rodata.interrupt_main_handler.str1.1)
 *(.rodata.conceal_seed_error.str1.1)
 *(.rodata.stm32_uart_serial_ops)
 *(.rodata.stm32mp1_clk_on)
 *(.rodata.stm32mp1_clk_gate)
 *(.rodata.interrupt_call_handlers.str1.1)
 *(.rodata.__do_panic.str1.1)
 *(.rodata.trace_ext_prefix)
 *(.rodata.thread_check_canaries.str1.1)
 *(.rodata.thread_init_threads.str1.1)
 *(.rodata.add_va_space.constprop.0.str1.1)
 *(.rodata.core_mmu_type_to_attr.str1.1)
 *(.rodata.core_init_mmu_map.str1.1)
 *(.rodata.core_mmu_map_region.str1.1)
 *(.rodata.core_mmu_init_ta_ram.str1.1)
 *(.rodata.__func__.3)
 *(.rodata.tee_mm_alloc.str1.1)
 *(.rodata.tee_mm_free.str1.1)
 *(.rodata.K)
 *(.rodata.__stack_chk_fail.str1.1)
 *(.rodata.kprintf.constprop.0.str1.1)
 *(.rodata.HEXDIGITS)
 *(.rodata.hexdigits)
 *(.rodata.trace_vprintf.str1.1)
 *(.rodata.lvl_strs.0)
  . = ALIGN(8);
  KEEP(*(SORT(.scattered_array*)));
  __rodata_init_end = .;
 }
 . = ALIGN(8);
 __ro_and_relro_data_init_end = .;
 __init_end = ALIGN(__ro_and_relro_data_init_end, (1 << (12)));
 __get_tee_init_end = __init_end;
 __init_size = __init_end - __init_start;
 __flatmap_init_ro_size = __init_end - __flatmap_init_ro_start;
 .rodata_pageable : ALIGN(8) {
  __rodata_pageable_start = .;
  *(.rodata*)
  __rodata_pageable_end = .;
 }
 .text_pageable : ALIGN(8) {
  __text_pageable_start = .;
  *(.text*)
  . = ALIGN((1 << (12)));
  __text_pageable_end = .;
 }
 __pageable_part_end = .;
 __pageable_part_start = __init_end;
 __pageable_start = __init_start;
 __pageable_end = __pageable_part_end;
 ASSERT(0x2ffc0000 >= 0x2ffc0000,
  "Load address before start of physical memory")
 ASSERT(0x2ffc0000 < (0x2ffc0000 + 0x00040000),
  "Load address after end of physical memory")
 ASSERT((0x2ffc0000 + 0x00040000 - __init_end) >
  (1 << (12)), "Too few free pages to initialize paging")
 __end = .;
 ASSERT(. <= (0x2ffc0000 + 0x00200000),
  "TEE_RAM_VA_SIZE is too small")
 . = 0x2ffc0000 + 0x00200000;
 _end_of_ram = .;
 .dynamic : { *(.dynamic) }
 .hash : { *(.hash) }
 .dynsym : { *(.dynsym) }
 .dynstr : { *(.dynstr) }
 .rel : {
  *(.rel.*)
 }
 .rela : {
  *(.rela.*)
 }
 ASSERT(SIZEOF(.rel) == 0, "Relocation entries not expected")
 ASSERT(SIZEOF(.rela) == 0, "Relocation entries not expected")
 /DISCARD/ : {
  *(.comment .note .eh_frame .interp)
  *(__keep_meta_vars*)
 }
}
__vcore_unpg_rx_start = __flatmap_unpg_rx_start;
__vcore_unpg_ro_start = __flatmap_unpg_ro_start;
__vcore_unpg_rx_size = __flatmap_unpg_rx_size + __flatmap_unpg_ro_size;
__vcore_unpg_ro_size = 0;
__vcore_unpg_rx_end = __vcore_unpg_rx_start + __vcore_unpg_rx_size;
__vcore_unpg_ro_end = __vcore_unpg_ro_start + __vcore_unpg_ro_size;
__vcore_unpg_rw_start = __flatmap_unpg_rw_start;
__vcore_unpg_rw_size = __flatmap_unpg_rw_size;
__vcore_unpg_rw_end = __vcore_unpg_rw_start + __vcore_unpg_rw_size;
__vcore_init_rx_start = __flatmap_init_rx_start;
__vcore_init_ro_start = __flatmap_init_ro_start;
__vcore_init_rx_size = __flatmap_init_rx_size + __flatmap_init_ro_size +
         (0x2ffc0000 + 0x00040000 - (__flatmap_init_ro_start + __flatmap_init_ro_size));
__vcore_init_ro_size = 0;
__vcore_init_rx_end = __vcore_init_rx_start + __vcore_init_rx_size;
__vcore_init_ro_end = __vcore_init_ro_start + __vcore_init_ro_size;
